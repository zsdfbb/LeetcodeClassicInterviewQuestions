#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>

// 收集到所有的上坡，一定是最大收益
int maxProfit(int* prices, int pricesSize)
{
    int res = 0;
    for (int i = 1; i < pricesSize ; i++) {
        int t = prices[i] - prices[i-1];
        if (t > 0) {
            res += t;
        }
    }
    return res;
}


// 定义状态 dp[i][0] 表示第 i 天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。

// 考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1][1]，这时候我们要将其卖出，并获得 prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程：
// dp[i][0]=max{dp[i−1][0],dp[i−1][1]+prices[i]}

// 再来考虑 dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 dp[i−1][1]，或者前一天结束时还没有股票，即 dp[i−1][0]，这时候我们要将其买入，并减少 prices[i] 的收益。可以列出如下的转移方程：
// dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}
int maxProfit1(int* prices, int pricesSize)
{
    int dp[pricesSize][2];
    
}

int main()
{
    // 示例 1：
    // 输入：prices = [7,1,5,3,6,4]
    // 输出：7
    // 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
    // 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
    // 最大总利润为 4 + 3 = 7 。

    // 示例 2：
    // 输入：prices = [1,2,3,4,5]
    // 输出：4
    // 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
    // 最大总利润为 4 。

    // 示例 3：
    // 输入：prices = [7,6,4,3,1]
    // 输出：0
    // 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。
}